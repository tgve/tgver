---
title: "The power of R + JS"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{The power of R + JS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

<!-- R users are aware of the RStudio approach to bringing R and JavaScript together in ShinyJS. They are also aware how useful RMarkdown documents (such as this one) are. In this vignette we will outline the approach TGVE has taken to bring together a front-end application such as the TGVE and R. -->

One limitation of browsers, in the case of Single Page applications and the power of JS libraries is access to Operating System (OS) resources (such as the file system). The limitation of Python and R (data science languages) is they are not compiled for use in browsers.

To show how the TGVE brings them together let us do some advanced processing in R and then view the result in the TGVE. For this purpose we will use these R packages: `edgebundle`, `igraph` and `ggplot2` first.

Following is adapted from [here](https://github.com/schochastics/edgebundle).

```{r data-prep}
library(igraph)
library(edgebundle)
library(ggplot2)

g = us_flights
xy = cbind(V(g)$longitude, V(g)$latitude)
verts = data.frame(x = V(g)$longitude, y = V(g)$latitude)

states = map_data("state")

pbundle = edge_bundle_path(g, xy, max_distortion = 12, weight_fac = 2, segments = 50)
# caching the heavy processing
# saveRDS(pbundle, "vignettes/pbundle.Rds")
# pbundle = readRDS("pbundle.Rds")

# edge list
el = get.edgelist(g)
colnames(el) = c("from", "to")

# get names of airports in verts
verts.with.names = data.frame(x = V(g)$longitude, y = V(g)$latitude, V(g)$name)
colnames(verts.with.names) = c("x", "y", "name")
# intermediate
from = verts.with.names[match(el[,"from"], verts.with.names$name), c("x", "y")]
to = verts.with.names[match(el[,"to"], verts.with.names$name), c("x", "y")]
# create matrix for sf
m = cbind(from, to)
library(sf)
sfc = lapply(1:nrow(m), function(x) st_linestring(matrix(unlist(m[x,]), ncol = 2, byrow = TRUE)))
sfc = st_sfc(sfc, crs = 4326)
```


First, let us have a look at the lines without bundling the edges using `plot`:
```{r plot-no-bundling, out.width='90%'}
plot(sfc)
```

Using the `edgebundle::edge_bundle_path` function, please see the `edgebundle` package for details of the algorithm, and using `ggplot` let us plot the bundled paths:
```{r ggplot-no-bundle, out.width='90%'}
ggplot() +
  geom_path(data = pbundle, aes(x, y, group = group),
            col = "orange", size = 0.05) +
  geom_path(data = pbundle, aes(x, y, group = group),
            col = "white", size = 0.005) +
  labs(title = "Edge-Path Bundling") +
  ggraph::theme_graph(background = "black") +
  theme(plot.title = element_text(color = "white"))

```

## Interactive

Using the TGVE (no bundling), we can build an instance naming the `layerName` which is optional as the TGVE will try to detect the geometry and choses the appropriate layer:

```{r tgve1, out.width='100%'}
library(tgver)
p = "~/Downloads"
tp = file.path(p, "tgve")
unlink(tp, recursive = TRUE)
# some random line width
# df = data.frame(lw=runif(length(sfc), min=1, max=5))
run_tgve = function(layerName="line") {
  setup(p)
  gj = geojsonsf::sf_geojson(st_as_sf(sfc), simplify = FALSE)
  ip = build(tp, data = gj,
             hideChartGenerator="true",
             viewport="{zoom:3,pitch:0,bearing:0}",
             layerName=layerName)
  knitr::include_url(ip)
}
run_tgve()
```

Let us see how the bundled data looks on the TGVE, we need to use the `path` layer for now, as the TGVE can still do with more advanced layer detection in future:

```{r tgve2, out.width='100%'}
# convert the pbundle into sf
sfc = lapply(1:length(unique(pbundle$group)), function(x) st_linestring(matrix(unlist(pbundle[pbundle$group == x, 1:2]), ncol = 2)))
sfc = st_sfc(sfc, crs = 4326)
# plot(sfc)
p = file.path(p, "edge-tgve")
tp = file.path(p, "tgve")
unlink(tp, recursive = TRUE)
run_tgve(layerName = "path")
```

